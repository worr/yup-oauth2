initSidebarItems({"enum":[["EitherOrBoth","A value yielded by `ZipLongest`. Contains one or two values, depending on which of the input iterators are exhausted."]],"fn":[["equal","Return **true** if both iterators produce equal sequences (elements pairwise equal and sequences of the same length), **false** otherwise."],["linspace","Return an iterator with `n` elements, where the first element is `a` and the last element is `b`."],["times","Return an iterator with `n` elements, for simple repetition a particular number of times. The iterator yields a counter."]],"macro":[["icompr!","`icompr` as in “iterator comprehension” allows creating a mapped iterator with simple syntax, similar to set builder notation, and directly inspired by Python. Supports an optional filter clause."],["iproduct!","Create an iterator over the “cartesian product” of iterators."],["izip!","Create an iterator running multiple iterators in lockstep."]],"mod":[["misc","A module of helper traits and iterators that are not intended to be used directly."],["size_hint","Arithmetic on **Iterator** *.size_hint()* values."]],"struct":[["Batching","A “meta iterator adaptor”. Its closure recives a reference to the iterator and may pick off as many elements as it likes, to produce the next iterator element."],["Dedup","An iterator adaptor that removes duplicates from sections of consecutive identical elements.  If the iterator is sorted, all elements will be unique."],["FnMap","A clonable iterator adaptor to map elementwise from one iterator to another, using a function pointer."],["GroupBy","An iterator adaptor that groups iterator elements. Consecutive elements that map to the same key (“runs”), are returned as the iterator elements."],["ISlice","An iterator adaptor that yields a subset (a slice) of the base iterator."],["Interleave","An iterator adaptor that alternates elements from two iterators until both run out."],["Intersperse","An iterator adaptor to insert a particular value between each element of the adapted iterator."],["Linspace","An iterator of a sequence of evenly spaced floats."],["Merge","An iterator adaptor that merges the two base iterators in ascending order. If both base iterators are sorted (ascending), the result is sorted."],["MultiPeek","An iterator adaptor that allows the user to peek at multiple *.next()* values without advancing itself."],["Product","An iterator adaptor that iterates over the cartesian product of the element sets of two iterators **I** and **J**."],["PutBack","An iterator adaptor that allows putting back a single item to the front of the iterator."],["RcIter","A wrapper for **Rc<RefCell<I>>**, that implements the **Iterator** trait."],["RepeatN","An iterator that repeats an element exactly *n* times."],["Step","An iterator adaptor that steps a number elements in the base iterator for each iteration."],["Stride","An iterator similar to the slice iterator, but with a certain number of steps (the stride) skipped per iteration."],["StrideMut","The mutable equivalent of Stride."],["Tee","One half of an iterator pair where both return the same elements."],["Times","A simple iterator to repeat a given number of times"],["Zip","An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep."],["ZipLongest","An iterator which iterates two other iterators simultaneously"]],"trait":[["Itertools","Extra iterator methods for arbitrary iterators"]],"type":[["MergeAscend","An ascending order merge iterator created with *.merge()*."]]});